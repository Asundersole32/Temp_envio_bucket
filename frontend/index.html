<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <title>Upload ZIP SAEB</title>
  <style>
    body { background: linear-gradient(135deg, #8540b7 100%); min-height: 100vh; display:flex; justify-content:center; align-items:center; margin:0; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
    .upload-container { background:#fff; border-radius:15px; box-shadow:0 10px 30px rgba(0,0,0,.2); padding:40px; width:90%; max-width:560px; border:3px solid #9dfc40; }
    h1 { margin-top:0; }
    .file-input-label, #uploadButton { display:inline-block; padding:12px 20px; background:#9dfc40; color:#fff; border:2px solid #388E3C; border-radius:8px; cursor:pointer; font-weight:600; }
    .file-input-label:hover, #uploadButton:hover { background:#388E3C; transform: translateY(-2px); }
    #fileInput { display:none; }
    #uploadButton:disabled { background:#bbb; border-color:#999; cursor:not-allowed; transform:none; }
    .file-item { margin: 10px 0; padding:10px; background:#f7f7f7; border:1px solid #e5e5e5; border-radius:6px; position:relative;}
    .remove-file { position:absolute; right:10px; top:8px; color:#c00; font-weight:bold; cursor:pointer;}
    .progress-container { width:100%; background:#eee; border-radius:5px; height:20px; margin-top:8px; position:relative;}
    .progress-bar { height:20px; background:#9dfc40; border-radius:5px; width:0%; transition: width .2s; }
    .progress-text { position:absolute; left:50%; top:50%; transform:translate(-50%, -50%); font-size:12px; color:#333; font-weight:bold;}
    .status-message { margin-top:15px; padding:12px; border-radius:8px; }
    .success { background:#d4edda; border:1px solid #c3e6cb; color:#155724; }
    .error { background:#f8d7da; border:1px solid #f5c6cb; color:#721c24; }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
</head>
<body>
  <div class="upload-container">
    <h1>Upload ZIP SAEB</h1>
    <label for="fileInput" class="file-input-label">Selecionar ZIPs</label>
    <input type="file" id="fileInput" multiple accept=".zip" />
    <div id="fileList"></div>
    <button id="uploadButton" disabled>Enviar & Processar</button>
    <div id="statusMessage" class="status-message"></div>
    <div id="statusMessage" class="status-message"></div>
    <!-- NOVO: painel de resumo -->
    <div id="summaryPanel" class="status-message" style="display:none;"></div>
  </div>

  <script>
    const API_BASE = 'https://saeb-upload-290679812219.us-central1.run.app'; // se servir via o mesmo dom√≠nio do Cloud Run, deixe vazio. Ou coloque a URL do backend.
    const fileInput = document.getElementById('fileInput');
    const fileList = document.getElementById('fileList');
    const uploadButton = document.getElementById('uploadButton');
    const statusMessage = document.getElementById('statusMessage');

    let files = [];
    let sessionId = crypto.randomUUID();
    let eventSource = null;
    let overallStartMs = null;
    let totalZipsSelected = 0;

    fileInput.addEventListener('change', () => {
      files = [...files, ...Array.from(fileInput.files)];
      renderFiles();
      fileInput.value = '';
    });

    function renderFiles() {
      fileList.innerHTML = '';
      if (files.length === 0) {
        uploadButton.disabled = true;
        return;
      }
      uploadButton.disabled = false;
      files.forEach((f, i) => {
        const item = document.createElement('div');
        item.className = 'file-item';
        item.innerHTML = `
          <strong>${f.name}</strong> (${formatFileSize(f.size)})
          <span class="remove-file" data-i="${i}">‚úñ</span>
          <div class="progress-container">
            <div class="progress-bar" id="bar-${i}"></div>
            <div class="progress-text" id="txt-${i}">0%</div>
          </div>
        `;
        fileList.appendChild(item);
      });
      document.querySelectorAll('.remove-file').forEach(el => {
        el.onclick = (e) => {
          const idx = +e.target.dataset.i;
          files.splice(idx, 1);
          renderFiles();
        };
      });
    }

    uploadButton.addEventListener('click', async () => {
      if (files.length === 0) return;
      uploadButton.disabled = true;
      statusMessage.className = 'status-message';
      statusMessage.textContent = 'Iniciando uploads‚Ä¶';

      try {
        overallStartMs = performance.now();
        totalZipsSelected = files.length;
        document.getElementById('summaryPanel').style.display = 'none';
        document.getElementById('summaryPanel').textContent = '';
        // 1) Para cada arquivo, inicia sess√£o resumable e envia
        const objectNames = [];
        for (let i = 0; i < files.length; i++) {
          const f = files[i];
          const meta = await getSignedUrl(f);
          const sessionUrl = await startResumableSession(meta.uploadUrl, f);
          await uploadWithProgress(sessionUrl, f, i);
          objectNames.push(meta.objectName);
        }

        statusMessage.textContent = 'Uploads conclu√≠dos. Iniciando processamento‚Ä¶';

        // 2) Abre SSE para progresso
        if (eventSource) eventSource.close();
        eventSource = new EventSource(`${API_BASE}/progress/${sessionId}`);

        eventSource.addEventListener('progress', evt => {
          const data = JSON.parse(evt.data);
          const idx = files.findIndex(ff => ff.name === data.zipId);
          if (idx >= 0) {
            const bar = document.getElementById(`bar-${idx}`);
            const txt = document.getElementById(`txt-${idx}`);
            if (bar) bar.style.width = `${data.progress}%`;
            if (txt) txt.textContent = `${data.progress}% (${data.uploaded}/${data.totalFiles})`;
          }
        });

        eventSource.addEventListener('completed', evt => {
          const payload = JSON.parse(evt.data);
          // suporte a 2 formatos: antigo (results puro) ou novo (results + summary)
          const results = payload.results || payload;
          const summary = payload.summary || null;
          const summaryFromBackend = payload.summary || null;

          // 1) total processado (arquivos internos)
          let totalProcessed = 0;
          Object.values(results).forEach(zip => {
            totalProcessed += (zip.files || []).length;
          });

          // 2) tempo total (upload + processamento)
          const elapsedMs = Math.max(0, (performance.now() - (overallStartMs || performance.now())));
          const elapsedSec = (elapsedMs / 1000).toFixed(2);

          statusMessage.className = 'status-message success';
          statusMessage.textContent = '‚úÖ Processamento conclu√≠do!';
          downloadReportXLSX(results, summary);

          // 3) Monta o painel de resumo
          const summaryPanel = document.getElementById('summaryPanel');
          summaryPanel.style.display = 'block';
          const zipsCount = totalZipsSelected; // zips efetivamente enviados
          const processedCount = summaryFromBackend?.filesProcessed ?? totalProcessed;
          const niceTime =
            summaryFromBackend?.elapsedMs != null
              ? (summaryFromBackend.elapsedMs / 1000).toFixed(2)
              : elapsedSec;

          summaryPanel.className = 'status-message';
          summaryPanel.innerHTML = `
            <div style="background:#e9f7ff;border:1px solid #b6e0ff;color:#084c61;border-radius:8px;padding:12px;">
              <div style="font-weight:700;margin-bottom:6px;">Resumo do processo</div>
              <div>‚è±Ô∏è Tempo total: <strong>${niceTime}s</strong></div>
              <div>üì¶ ZIPs enviados: <strong>${zipsCount}</strong></div>
              <div>üóÇÔ∏è Arquivos processados: <strong>${processedCount}</strong></div>
            </div>
          `;

          if (eventSource) eventSource.close();
          files = [];
          renderFiles();
          uploadButton.disabled = false; // permite novo ciclo
        });

        eventSource.addEventListener('error', evt => {
          let msg = 'Erro no processamento';
          try { msg = JSON.parse(evt.data).message || msg; } catch {}
          statusMessage.className = 'status-message error';
          statusMessage.textContent = '‚ùå ' + msg;
          if (eventSource) eventSource.close();
          uploadButton.disabled = false;
        });

        // 3) Chama processamento no backend (streaming do ZIP do GCS)
        await fetch(`${API_BASE}/process`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ sessionId, objects: objectNames })
        });

      } catch (err) {
        statusMessage.className = 'status-message error';
        statusMessage.textContent = '‚ùå ' + (err.message || 'Falha no envio');
        uploadButton.disabled = false;
      }
    });

    async function getSignedUrl(file) {
      console.log('[upload] requesting signed-url for', file && file.name);
      const qs = new URLSearchParams({
        fileName: file.name,
        contentType: file.type || 'application/zip',
        sessionId
      });
      const r = await fetch(`${API_BASE}/signed-url?${qs.toString()}`);
      if (!r.ok) throw new Error('Falha ao obter Signed URL');
      return r.json(); // {uploadUrl, objectName}
    }

    async function startResumableSession(uploadUrl, file) {
      const ct = file.type || 'application/zip';
      const r = await fetch(uploadUrl, {
        method: 'POST',
        headers: {
          'x-goog-resumable': 'start',
          'Content-Type': ct
        }
      });
      if (!r.ok) {
        const msg = await r.text().catch(()=>''); 
        throw new Error('Falha ao iniciar sess√£o resumable: ' + r.status + ' ' + msg);
      }
      const loc = r.headers.get('location') || r.headers.get('Location');
      if (!loc) {
        throw new Error('Header Location n√£o vis√≠vel (verifique CORS do bucket para expor "Location")');
      }
      return loc;
    }

    function uploadWithProgress(sessionUrl, file, index) {
      return new Promise((resolve, reject) => {
        const xhr = new XMLHttpRequest();
        xhr.open('PUT', sessionUrl, true);

        xhr.upload.onprogress = (e) => {
          if (e.lengthComputable) {
            const pct = Math.round((e.loaded / e.total) * 100);
            const bar = document.getElementById(`bar-${index}`);
            const txt = document.getElementById(`txt-${index}`);
            if (bar) bar.style.width = pct + '%';
            if (txt) txt.textContent = pct + '%';
          }
        };

        xhr.onload = () => {
          if (xhr.status >= 200 && xhr.status < 300) resolve();
          else reject(new Error('Falha no upload resumable'));
        };
        xhr.onerror = () => reject(new Error('Erro de rede no upload'));

        xhr.send(file);
      });
    }

    function formatFileSize(bytes) {
      if (bytes < 1024) return bytes + ' B';
      if (bytes < 1048576) return (bytes / 1024).toFixed(1) + ' KB';
      return (bytes / 1048576).toFixed(1) + ' MB';
    }

    function downloadReport(results) {
      // Gera CSV simples com nome;url
      let lines = ['Arquivo,URL'];
      Object.values(results).forEach(zip => {
        zip.files.forEach(f => {
          lines.push(`"${f.name}","${f.url}"`);
        });
      });
      const blob = new Blob([lines.join('\n')], { type: 'text/csv;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'relatorio_arquivos.csv';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }
  
    function downloadReportXLSX(results, summary) {
      // Primeira aba: Detalhes de todos os arquivos
      const rowsDetails = [["Arquivo", "URL", "Status"]];
      Object.values(results).forEach(zip => {
        (zip.files || []).forEach(f => {
          const url = (f.url || "");
          const status = f.status === 'success' ? '‚úÖ Sucesso' : '‚ùå Falha';
          rowsDetails.push([f.name || "", url, status]);
        });
      });

      // Segunda aba: Resumo por ZIP
      const rowsSummary = [["Nome do ZIP", "Total de Arquivos", "Sucesso", "Falhas", "Status"]];
      if (summary && summary.zipStatus) {
        Object.entries(summary.zipStatus).forEach(([zipName, stats]) => {
          const status = stats.failed === 0 ? '‚úÖ Completo' : '‚ö†Ô∏è Parcial';
          rowsSummary.push([
            zipName, 
            stats.total, 
            stats.success, 
            stats.failed,
            status
          ]);
        });
        
        // Adicionar linha de totais
        rowsSummary.push([]);
        rowsSummary.push([
          "TOTAL GERAL",
          summary.filesProcessed + summary.filesFailed,
          summary.filesProcessed,
          summary.filesFailed,
          summary.filesFailed === 0 ? '‚úÖ Todos processados' : '‚ö†Ô∏è Com falhas'
        ]);
      }

      const wb = XLSX.utils.book_new();
      const wsDetails = XLSX.utils.aoa_to_sheet(rowsDetails);
      const wsSummary = XLSX.utils.aoa_to_sheet(rowsSummary);

      // Ajustar largura das colunas
      wsDetails["!cols"] = [{wch: 40}, {wch: 80}, {wch: 15}];
      wsSummary["!cols"] = [{wch: 40}, {wch: 15}, {wch: 15}, {wch: 15}, {wch: 20}];

      XLSX.utils.book_append_sheet(wb, wsDetails, "Detalhes dos Arquivos");
      XLSX.utils.book_append_sheet(wb, wsSummary, "Resumo por ZIP");

      XLSX.writeFile(wb, "relatorio_processamento.xlsx");
    }
    
</script>
</body>
</html>
